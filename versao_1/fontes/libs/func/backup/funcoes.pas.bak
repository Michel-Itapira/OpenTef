unit funcoes;

{$mode ObjFPC}{$H+}

interface

uses
    Classes, SysUtils, StrUtils, ZDataset, DB, rxmemds, IdContext, syncobjs, def;

type

    TPinPadModelo = (pNDF, pGERTEC_PPC930);
    TConexaoTipo = (cnCaixa, cnServico, cnNaoDefinido);
    TAguardaEvento = (agTempo, agEvento, agAborta);
    TRetorno = procedure(VP_Transmissao_ID: PChar; VP_ProcID, VP_Codigo: integer; VP_Dados: PChar); stdcall;
    TServidorRecebimento = procedure(VP_Codigo:Integer; VP_Transmissao_ID, VP_DadosRecebidos: string; var VO_AContext: TIdContext);
    TServidorRecebimentoLib = function(VP_Codigo:Integer;VP_Transmissao_ID, VP_DadosRecebidos: PChar; VP_IP: PChar; VP_ID: integer): integer; stdcall;
    TConexaoStatus = (csDesconectado, csLink, csChaveado, csLogado, csNaoInicializado);
    TTransacaoStatus = (tsEfetivada, tsNegada, tsCancelada, tsProcessando, tsAguardandoComando, tsNaoLocalizada, tsInicializada, tsComErro);


    TPermissao = (pmS, pmC, pmA, pmU);  // pmS=permissao de sistema
    // pmC=permissao de controlador permissao maxima
    // pmA permissao de administrador pode gerenciar as transacao e fazer cadastros
    // pmU permissao de usuario consulta e visualizacao das transacoes

    TTag = record
        Tag: ansistring;
        Qt: ansistring;
        Tamanho: longint;
        Dados: ansistring;
    end;

    { TTEmporizadorEvento }

    TTEmporizadorTThread = class(TThread)
    private
        fTempo: cardinal;
        fTemporizador: Pointer;
    protected
        procedure Execute; override;
    public
        f_parar: boolean;
        constructor Create(VP_Suspenso: boolean; VP_Temporizador: Pointer);
    end;

    { TMensagem }
    TMensagem = class
    private
        fTags: array of TTag;
    public
        function CarregaTags(VP_Dados: ansistring): integer;
        function TagToStr(var VO_Dados: ansistring): integer;
        function AddComando(VP_Tag, VP_Dados: ansistring): integer;
        function GetComando(var VO_Tag: ansistring; var VO_Dados: ansistring): integer;
        function GetComandoInt(var VO_Tag: integer; var VO_Dados: ansistring): integer;
        function GetTag(VP_Tag: ansistring; var VO_Dados: ansistring): integer;
        function GetTag(VP_Posicao: integer; var VO_Tag: ansistring; var VO_Dados: ansistring): integer;
        function GetTag(VP_Posicao: integer; var VO_Tag: TTag): integer;
        function GetTag(VP_Tag: ansistring; var VO_Dados: int64): int64;
        function GetTagAsAstring(VP_Tag: ansistring): ansistring;
        function Comando(): ansistring;
        function ComandoDados(): ansistring;
        function TagsAsString: ansistring;
        function TagCount(): integer;
        function GetTagAsInteger(VP_Tag: ansistring): integer;
        function AddTag(VP_Tag, VP_Dados: ansistring): integer;
        function AddTag(VP_Tag: ansistring; VP_Dados: integer): integer;
        procedure Limpar;
        constructor Create;
    end;

    { TTEmporizador }
    TTemporizador = class
    private
        fTEmporizadorTThread: TTEmporizadorTThread;
        fEvento: TAguardaEvento;

    public
        V_Dados: string;
        V_Executado: boolean;
        V_Aguardando: boolean;
        V_Aborta: boolean;
        V_ID: string;
        constructor Create;
        procedure parar;
        procedure abortar;
        function aguarda(VP_Tempo: cardinal; VP_Reaguardar: boolean; VP_Temporizador: Pointer): TAguardaEvento;
        destructor Destroy; override;

    end;

    { TTransacao }

    TTransacao = class
        Mensagem: TMensagem;
        Temporizador: TTemporizador;
    private
        function GetErro: integer;
        procedure SetErro(VP_Erro: integer);
        function GetStatus: TTransacaoStatus;
        procedure SetStatus(VP_Status: TTransacaoStatus);
        function GetID: ansistring;

    public
        constructor Create(VP_Terminal_Tipo: ansistring; VP_Terminal_ID: int64; VP_TransacaoString: ansistring);
        destructor Destroy; override;
        function AsString: ansistring;
        function TempoAguarda: integer;
        property erro: integer read GetErro write SetErro;
        property ID: ansistring read GetID;
        property STATUS: TTransacaoStatus read GetSTATUS write SetStatus;
    end;


    { TDFuncoes }

    TDFuncoes = class(TDataModule)
    private
    public
    end;

procedure StrToRxMemData(VP_Dados: ansistring; var VO_MemDataSet: TRxMemoryData);
function RxMemDataToStr(VO_MemDataSet: TRxMemoryData): ansistring;
function ZQueryToStrRxMemData(VO_ZQuery: TZQuery): ansistring;
procedure CriarChaveTerminal(var VO_Chave: ansistring);
procedure GravaLog(VP_Arquivo: string; VP_Modulo_ID: integer; VP_Tag_Comando, VP_Unit, VP_Linha, VP_Ocorrencia, VP_Tag: ansistring; VP_CodigoErro: integer);
function PermissaoToStr(VP_Permissao: TPermissao): ansistring;
function StrToPermissao(VP_Permissao: ansistring): TPermissao;
function ConexaoStatusToInt(VP_ConexaoStatus: TConexaoStatus): integer;
function IntToConexaoStatus(VP_ConexaoStatus: integer): TConexaoStatus;
function ConexaoTipoToInt(VP_ConexaoTipo: TConexaoTipo): integer;
function ConexaoTipoToStr(VP_ConexaoTipo: TConexaoTipo): string;
function IntToConexaoTipo(VP_ConexaoTipo: integer): TConexaoTipo;
function IntToTransacaoStatus(VP_TranscaoStatus: integer): TTransacaoStatus;
function TransacaoStatusToInt(VP_TransacaoStatus: TTransacaoStatus): integer;
procedure CopiaDadosSimples(VO_TOrigemMemDataset: TRxMemoryData; VO_TDestinoMemDataset: TRxMemoryData; VL_Linha: boolean = False);



function mensagemcreate(var VP_Mensagem: Pointer): integer; stdcall;
function mensagemcarregatags(VP_Mensagem: Pointer; VP_Dados: PChar): integer; stdcall;
function mensagemcomando(VP_Mensagem: Pointer): PChar; stdcall;
function mensagemcomandodados(VP_Mensagem: Pointer): PChar; stdcall;
procedure mensagemfree(VP_Mensagem: Pointer); stdcall;
function mensagemaddtag(VP_Mensagem: Pointer; VP_Tag, VP_Dados: PChar): integer; stdcall;
function mensagemaddcomando(VP_Mensagem: Pointer; VP_Tag, VP_Dados: PChar): integer; stdcall;
function mensagemtagasstring(VP_Mensagem: Pointer): PChar; stdcall;
function mensagemtagcount(VP_Mensagem: Pointer): integer; stdcall;
function mensagemgettag(VP_Mensagem: Pointer; VP_Tag: PChar; var VO_Dados: PChar): integer; stdcall;
function mensagemgettagidx(VP_Mensagem: Pointer; VL_Idx: integer; var VO_Tag: PChar; var VO_Dados: PChar): integer; stdcall;
function mensagemtagtostr(VP_Mensagem: Pointer; var VO_Dados: PChar): integer; stdcall;

var
    VF_Sequencia: longint;
    VF_CriticoLog: TRTLCriticalSection;


implementation

function mensagemcreate(var VP_Mensagem: Pointer): integer; stdcall;
begin
    Result := 0;
    Pointer(VP_Mensagem) := pointer(TMensagem.Create);

end;

function mensagemcarregatags(VP_Mensagem: Pointer; VP_Dados: PChar): integer; stdcall;
begin
    Result := TMensagem(VP_Mensagem).CarregaTags(VP_Dados);
end;

function mensagemcomando(VP_Mensagem: Pointer): PChar; stdcall;
begin
    Result := PChar(TMensagem(VP_Mensagem).Comando());
end;

function mensagemcomandodados(VP_Mensagem: Pointer): PChar; stdcall;
begin
    Result := PChar(TMensagem(VP_Mensagem).ComandoDados());
end;

procedure mensagemfree(VP_Mensagem: Pointer); stdcall;
begin
    if Assigned(VP_Mensagem) then
        TMensagem(VP_Mensagem).Free;
end;

function mensagemaddtag(VP_Mensagem: Pointer; VP_Tag, VP_Dados: PChar): integer; stdcall;
begin
    Result := TMensagem(VP_Mensagem).AddTag(VP_Tag, VP_Dados);
end;

function mensagemaddcomando(VP_Mensagem: Pointer; VP_Tag, VP_Dados: PChar): integer; stdcall;
begin
    Result := TMensagem(VP_Mensagem).AddComando(VP_Tag, VP_Dados);
end;

function mensagemtagasstring(VP_Mensagem: Pointer): PChar; stdcall;
begin
    Result := PChar(TMensagem(VP_Mensagem).TagsAsString());
end;

function mensagemtagcount(VP_Mensagem: Pointer): integer; stdcall;
begin
    Result := TMensagem(VP_Mensagem).TagCount;
end;

function mensagemgettag(VP_Mensagem: Pointer; VP_Tag: PChar; var VO_Dados: PChar): integer; stdcall;
var
    VL_Dados: ansistring;
begin
    VL_Dados := '';
    Result := TMensagem(VP_Mensagem).GetTag(VP_Tag, VL_Dados);

    VO_Dados := StrAlloc(Length(VL_Dados) + 1);
    StrPCopy(VO_Dados, VL_Dados);

end;

function mensagemgettagidx(VP_Mensagem: Pointer; VL_Idx: integer; var VO_Tag: PChar; var VO_Dados: PChar): integer; stdcall;
var
    VL_Dados, VL_Tag: ansistring;
begin
    VL_Tag := '';
    VL_Dados := '';
    Result := TMensagem(VP_Mensagem).GetTag(VL_Idx, VL_Tag, VL_Dados);

    VO_Dados := StrAlloc(Length(VL_Dados) + 1);
    StrPCopy(VO_Dados, VL_Dados);

    VO_Tag := StrAlloc(Length(VL_Tag) + 1);
    StrPCopy(VO_Tag, VL_Tag);
end;

function mensagemtagtostr(VP_Mensagem: Pointer; var VO_Dados: PChar): integer; stdcall;
var
    VL_Dados: ansistring;

begin
    VL_Dados := '';
    Result := TMensagem(VP_Mensagem).TagToStr(VL_Dados);
    VO_Dados := StrAlloc(Length(VL_Dados) + 1);
    StrPCopy(VO_Dados, VL_Dados);
end;


{$R *.lfm}

{ TTemporizador }

constructor TTemporizador.Create;
begin
    VF_Sequencia := VF_Sequencia + 1;
    V_ID := IntToStr(VF_Sequencia);
    inherited Create;
    V_ID := V_ID + FormatDateTime('dd/mm/yyyy hh:mm:ss:zzz', Now);
    Randomize;
    V_Executado := False;
    V_Aborta := False;
    V_Dados := '';
    V_Aguardando := False;
    V_ID := V_ID + IntToStr(Random(999));
end;

procedure TTemporizador.parar;
begin
    V_Executado := True;
    V_Aguardando := False;
    V_Aborta := False;
    if Assigned(fTEmporizadorTThread) then
        if not fTEmporizadorTThread.f_parar then
        begin
            fTEmporizadorTThread.f_parar := True;
            fTEmporizadorTThread.Terminate;
        end;
end;

procedure TTemporizador.abortar;
begin
    V_Executado := False;
    V_Aguardando := False;
    V_Aborta := True;
    if Assigned(fTEmporizadorTThread) then
        if not fTEmporizadorTThread.f_parar then
        begin
            fTEmporizadorTThread.f_parar := True;
            fTEmporizadorTThread.Terminate;
        end;

end;

function TTemporizador.aguarda(VP_Tempo: cardinal; VP_Reaguardar: boolean; VP_Temporizador: Pointer): TAguardaEvento;
begin
    V_Aguardando := True;
    try
        if VP_Reaguardar then
            V_Executado := False;

        if V_Executado then
        begin
            Result := agEvento;
            Exit;
        end;
        fTEmporizadorTThread := TTEmporizadorTThread.Create(True, VP_Temporizador);
        fTEmporizadorTThread.fTempo := VP_Tempo;
        fTEmporizadorTThread.Start;
        fTEmporizadorTThread.WaitFor;
        if Assigned(fTEmporizadorTThread) then
            FreeAndNil(fTEmporizadorTThread);

        if V_Executado then
            Result := agEvento
        else
            Result := agTempo;
        if V_Aborta then
            Result := agAborta;

    finally
        V_Aguardando := False;
    end;

end;

destructor TTemporizador.Destroy;
begin
    if Assigned(fTEmporizadorTThread) then
        if not fTEmporizadorTThread.f_parar then
        begin
            fTEmporizadorTThread.f_parar := True;
            fTEmporizadorTThread.Terminate;
            fTEmporizadorTThread.WaitFor;
        end;
    inherited Destroy;
end;

{ TTEmporizadorEvento }

procedure TTEmporizadorTThread.Execute;
var
    VL_Data: TDateTime;
begin
    VL_Data := now;
    while not Terminated do
    begin
        sleep(1);
        if ((fTempo <> INFINITE) and
            ((TimeStampToMSecs(DateTimeToTimeStamp(now)) - TimeStampToMSecs(DateTimeToTimeStamp(VL_Data))) > fTempo)) then
        begin
            if Assigned(fTemporizador) then
                TTemporizador(fTemporizador).fEvento := agTempo;
            exit;
        end;
    end;
end;



constructor TTEmporizadorTThread.Create(VP_Suspenso: boolean; VP_Temporizador: Pointer);
begin
    inherited Create(VP_Suspenso);
    TTemporizador(VP_Temporizador).fEvento := agEvento;
    fTemporizador := VP_Temporizador;
    FreeOnTerminate := False;
    f_parar := False;

end;

{ TTransacao }

function TTransacao.GetErro: integer;
begin
    Result := Mensagem.GetTagAsInteger('00A5');
end;

procedure TTransacao.SetErro(VP_Erro: integer);
begin
    Mensagem.AddTag('00A5', VP_Erro);
end;

function TTransacao.GetStatus: TTransacaoStatus;
begin
    Result := IntToTransacaoStatus(Mensagem.GetTagAsInteger('00A4'));
end;

procedure TTransacao.SetStatus(VP_Status: TTransacaoStatus);
begin
    Mensagem.AddTag('00A4', TransacaoStatusToInt(VP_Status));
end;

function TTransacao.GetID: ansistring;
begin
    Result := Mensagem.GetTagAsAstring('0034');
end;


constructor TTransacao.Create(VP_Terminal_Tipo: ansistring; VP_Terminal_ID: int64; VP_TransacaoString: ansistring);
begin
    inherited Create;

    Mensagem := TMensagem.Create;

    if VP_TransacaoString <> '' then
    begin
        Mensagem.CarregaTags(VP_TransacaoString);
        Mensagem.AddComando('007A', Mensagem.ComandoDados());
        Exit;
    end;

    VF_Sequencia := VF_Sequencia + 1;
    Mensagem.AddComando('007A', '');
    Mensagem.AddTag('00A3', VP_Terminal_ID);
    Mensagem.AddTag('0051', 20000);
    Mensagem.AddTag('00A2', VP_Terminal_Tipo);
    Mensagem.AddTag('007C', FloatToStr(Now));
    Mensagem.AddTag('00A4', TransacaoStatusToInt(tsAguardandoComando));
    Mensagem.AddTag('0034', IntToStr(VF_Sequencia) + '-' + VP_Terminal_Tipo + '-' + IntToStr(VP_Terminal_ID) + '-' +
        FormatDateTime('dd/mm/yyyy hh:mm:ss:zzz', Now));

end;

destructor TTransacao.Destroy;
begin
    Mensagem.Free;
    Temporizador.Free;
    inherited Destroy;
end;

function TTransacao.AsString: ansistring;
begin
    Result := Mensagem.TagsAsString;
end;

function TTransacao.TempoAguarda: integer;
begin
    Result := Mensagem.GetTagAsInteger('0051');
end;

{ TDFuncoes }



function RxMemDataToStr(VO_MemDataSet: TRxMemoryData): ansistring;
var
    VL_MemString: TStringStream;
    VL_Mem: TMemoryStream;
    VL_String: ansistring;
    VL_bytes: array of byte;
    VL_i: integer;
begin
    VL_bytes := nil;

    VL_MemString := TStringStream.Create;
    VL_Mem := TMemoryStream.Create;

    VO_MemDataSet.SaveToStream(VL_Mem);

    VL_Mem.SaveToStream(VL_MemString);

    VL_String := VL_MemString.DataString;

    //  converte em bytes
    for VL_i := 0 to Length(VL_String) - 1 do
    begin
        SetLength(VL_bytes, Length(VL_bytes) + 1);
        VL_bytes[VL_i] := Ord(VL_String[VL_i + 1]);
    end;
    // converte em hex
    VL_String := '';
    for VL_i := 0 to Length(VL_bytes) - 1 do
        VL_String := VL_String + HexStr(VL_bytes[VL_i], 2);

    Result := VL_String;
    VL_MemString.Free;
    VL_Mem.Free;
end;

procedure StrToRxMemData(VP_Dados: ansistring; var VO_MemDataSet: TRxMemoryData);
var
    VL_bytes: array of byte;
    VL_i: integer;
    VL_String: ansistring;
    VL_MemString: TStringStream;
    VL_Mem: TMemoryStream;
begin

    VL_bytes := nil;
    // converte em bytes
    if VP_Dados = '' then
        exit;

    for VL_i := 0 to (Length(VP_Dados) div 2) - 1 do
    begin
        SetLength(VL_bytes, Length(VL_bytes) + 1);
        VL_bytes[VL_i] := Hex2Dec(copy(VP_Dados, ((VL_i + 1) * 2) - 1, 2));
    end;

    VL_String := '';


    for VL_i := 0 to Length(VL_bytes) - 1 do
    begin
        SetLength(VL_String, Length(VL_String) + 1);
        VL_String[VL_i + 1] := char(VL_bytes[VL_i]);
    end;

    VL_MemString := TStringStream.Create(VL_String);
    VL_Mem := TMemoryStream.Create;

    VL_MemString.SaveToStream(VL_Mem);

    VO_MemDataSet.LoadFromStream(VL_Mem);
    VL_MemString.Free;
    VL_Mem.Free;

end;


function ZQueryToStrRxMemData(VO_ZQuery: TZQuery): ansistring;
var
    VL_MemDataset: TRxMemoryData;
begin
    VL_MemDataset := TRxMemoryData.Create(nil);
    try
        VO_ZQuery.First;
        VL_MemDataset.LoadFromDataSet(VO_ZQuery, MaxInt, lmCopy);
        Result := RxMemDataToStr(VL_MemDataset);
    finally
        VL_MemDataset.Free;
    end;
end;


procedure CriarChaveTerminal(var VO_Chave: ansistring);
var
    VL_Chave: ansistring;
    I: integer;
begin
    VL_Chave := '';
    Randomize;
    for I := 0 to 50 do
    begin
        if Length(VL_Chave) < 50 then
            VL_Chave := VL_Chave + IntToStr(Random(999));
    end;
    VO_Chave := Copy(VL_Chave, 1, 50);
end;

procedure GravaLog(VP_Arquivo: string; VP_Modulo_ID: integer; VP_Tag_Comando, VP_Unit, VP_Linha, VP_Ocorrencia, VP_Tag: ansistring; VP_CodigoErro: integer);
var
    VL_Arquivo: TextFile;
begin
    if VP_Arquivo = '' then
        exit;
    EnterCriticalSection(VF_CriticoLog);
    try
        AssignFile(VL_Arquivo, PChar(VP_Arquivo));

        if not FileExists(VP_Arquivo) then
            Rewrite(VL_Arquivo)
        else
            Append(VL_Arquivo);

        WriteLn(VL_Arquivo, '[ Data:' + DateToStr(now) + '] - [ Hora:' + TimeToStr(now) + '] - [ Linha:' + VP_Linha +
            '] - [ Modulo_ID:' + IntToStr(VP_Modulo_ID) +
            ']- [ TagComando:' + VP_Tag_Comando + '] - [ Programa:' + C_Programa + '] - [ Unit:' +
            VP_Unit + '] - [ VersaoMensage:' + IntToStr(C_Mensagem) + '] - [ Versao:' + IntToStr(C_Versao[0]) + '.' +
            IntToStr(C_Versao[1]) + '.' + IntToStr(C_Versao[1]) + '] -  [ CodigoErro:' +
            IntToStr(VP_CodigoErro) + ']  - [ Ocorrencia:' + VP_Ocorrencia + '] - [ TMensagem:' + VP_Tag + ']');

        CloseFile(VL_Arquivo);

    finally
        LeaveCriticalSection(VF_CriticoLog);
    end;

end;

function PermissaoToStr(VP_Permissao: TPermissao): ansistring;
begin
    case VP_Permissao of
        pmA: Result := 'A';
        pmC: Result := 'C';
        pmU: Result := 'U';
        pmS: Result := 'S';
        else
            Result := '';
    end;
end;

function StrToPermissao(VP_Permissao: ansistring): TPermissao;
begin
    case VP_Permissao of
        'A': Result := pmA;
        'C': Result := pmC;
        'U': Result := pmU;
        'S': Result := pmS;
        else
            raise Exception.Create('Esse valor:"' + VP_Permissao + '" não é uma permissao');
    end;

end;

function ConexaoStatusToInt(VP_ConexaoStatus: TConexaoStatus): integer;
begin
    Result := Ord(VP_ConexaoStatus);
end;

function TransacaoStatusToInt(VP_TransacaoStatus: TTransacaoStatus): integer;
begin
    Result := Ord(VP_TransacaoStatus);
end;

function IntToTransacaoStatus(VP_TranscaoStatus: integer): TTransacaoStatus;
begin

    case VP_TranscaoStatus of
        0: Result := tsEfetivada;
        1: Result := tsNegada;
        2: Result := tsCancelada;
        3: Result := tsProcessando;
        4: Result := tsAguardandoComando;
        5: Result := tsNaoLocalizada;
        6: Result := tsInicializada;
        7: Result := tsComErro;

        else
            raise Exception.Create('Esse valor:"' + IntToStr(VP_TranscaoStatus) + '" não é um status valido');
    end;

end;


function IntToConexaoStatus(VP_ConexaoStatus: integer): TConexaoStatus;
begin
    Result := csDesconectado;
    case VP_ConexaoStatus of
        0: Result := csDesconectado;
        1: Result := csLink;
        2: Result := csChaveado;
        3: Result := csLogado;
        4: Result := csNaoInicializado;
        else
            raise Exception.Create('Esse valor:"' + IntToStr(VP_ConexaoStatus) + '" não é um status valido');
    end;

end;

function ConexaoTipoToInt(VP_ConexaoTipo: TConexaoTipo): integer;
begin
    Result := Ord(VP_ConexaoTipo);
end;

function ConexaoTipoToStr(VP_ConexaoTipo: TConexaoTipo): string;
begin
    Result := '';
    case VP_ConexaoTipo of
        cnCaixa: Result := 'Caixa';
        cnServico: Result := 'Servico';
        else
            raise Exception.Create('Esse valor:"' + IntToStr(ConexaoTipoToInt(VP_ConexaoTipo)) + '" não é um tipo valido');
    end;

end;

function IntToConexaoTipo(VP_ConexaoTipo: integer): TConexaoTipo;
begin
    Result := cnNaoDefinido;
    case VP_ConexaoTipo of
        0: Result := cnCaixa;
        1: Result := cnServico;
        else
            raise Exception.Create('Esse valor:"' + IntToStr(VP_ConexaoTipo) + '" não é um tipo valido');
    end;

end;


procedure CopiaDadosSimples(VO_TOrigemMemDataset: TRxMemoryData; VO_TDestinoMemDataset: TRxMemoryData; VL_Linha: boolean);
var
    I: int64;
begin
    if not Assigned(VO_TOrigemMemDataset) then
        exit;
    if not Assigned(VO_TDestinoMemDataset) then
        exit;
    if not VO_TOrigemMemDataset.Active then
        exit;
    if not VO_TDestinoMemDataset.Active then
        exit;
    if VL_Linha = False then
        VO_TOrigemMemDataset.First;
    while not VO_TOrigemMemDataset.EOF do
    begin
        for I := 0 to VO_TOrigemMemDataset.FieldCount - 1 do
        begin
            if VO_TDestinoMemDataset.FindField(VO_TOrigemMemDataset.Fields[I].FieldName) <> nil then
            begin
                if not (VO_TDestinoMemDataset.State in [dsInsert, dsEdit]) then
                    VO_TDestinoMemDataset.Insert;
                VO_TDestinoMemDataset.FindField(VO_TOrigemMemDataset.Fields[I].FieldName).AsString := VO_TOrigemMemDataset.Fields[I].AsString;
            end;
        end;
        if VO_TDestinoMemDataset.State in [DsInsert, DsEdit] then
            VO_TDestinoMemDataset.Post;
        if VL_Linha then
            Break;
        VO_TOrigemMemDataset.Next;
    end;

end;


function TMensagem.GetComando(var VO_Tag: ansistring; var VO_Dados: ansistring): integer;
begin
    if Length(fTags) > 0 then
    begin
        VO_Tag := fTags[0].Tag;
        self.GetTag(VO_Tag, VO_Dados);
    end;
    Result := 0;
end;

function TMensagem.GetComandoInt(var VO_Tag: integer; var VO_Dados: ansistring): integer;
begin
    if Length(fTags) > 0 then
    begin
        VO_Tag := Hex2Dec(fTags[0].Tag);
        self.GetTag(fTags[0].Tag, VO_Dados);
    end;
    Result := 0;
end;


function TMensagem.CarregaTags(VP_Dados: ansistring): integer;
var
    VL_Qtd, VL_Resto, VL_Tamanho: longint;

begin
    try
        // zera tags
        SetLength(fTags, 0);

        // testa pacote
        if Copy(VP_Dados, 1, 4) <> '0000' then
        begin
            Result := 18;
            Exit;
        end;

        //tamanho de digitos do tamanho total do pacote
        VL_Qtd := Hex2Dec(copy(VP_Dados, 5, 1));

        // tamanho na mensagem completa
        VL_Tamanho := StrToInt64(copy(VP_Dados, 6, VL_Qtd));

        if VL_Tamanho = 0 then
        begin
            Result := 19;
            Exit;
        end;

        if VL_Tamanho <> Length(VP_Dados) then
        begin
            Result := 20;
            Exit;
        end;

        VP_Dados := Copy(VP_Dados, VL_Qtd + 6, Length(VP_Dados) - (5 + VL_Qtd));

        VL_Resto := Length(VP_Dados);

        while True do
        begin
            SetLength(fTags, Length(fTags) + 1);
            fTags[Length(fTags) - 1].Tag := Copy(VP_Dados, 1, 4);
            fTags[Length(fTags) - 1].Qt := Copy(VP_Dados, 5, 1);
            fTags[Length(fTags) - 1].Tamanho :=
                StrToInt64Def(Copy(VP_Dados, 6, Hex2Dec(fTags[Length(fTags) - 1].Qt)), 0);
            fTags[Length(fTags) - 1].Dados :=
                Copy(VP_Dados, 6 + Hex2Dec(fTags[Length(fTags) - 1].Qt), fTags[Length(fTags) - 1].Tamanho);

            VP_Dados := Copy(VP_Dados, 6 + Hex2Dec(fTags[Length(fTags) - 1].Qt) + fTags[Length(fTags) - 1].Tamanho, MaxInt);

            if Length(VP_Dados) >= VL_Resto then
            begin
                Result := 21;
                Exit;
            end;
            VL_Resto := Length(VP_Dados);

            if VL_Resto = 0 then
                Break;

        end;
        Result := 0;

    except
        Result := 30;
    end;
end;

function TMensagem.TagToStr(var VO_Dados: ansistring): integer;
var
    VL_Digitos, i: integer;
    VL_TamanhoPacote: longint;
    VL_Dados: ansistring;

begin

    VL_Dados := '';
    if length(fTags) = 0 then
    begin
        Result := 23;
        Exit;
    end;
    for i := 0 to length(fTags) - 1 do
    begin
        VL_Dados := VL_Dados + fTags[i].Tag + fTags[i].Qt + IntToStr(fTags[i].Tamanho) + fTags[i].Dados;
    end;
    VL_TamanhoPacote := length(VL_Dados) + 5;

    VL_Digitos := Length(IntToStr(VL_TamanhoPacote));

    VL_Digitos := Length(IntToStr(VL_TamanhoPacote + VL_Digitos));

    VL_TamanhoPacote := VL_TamanhoPacote + VL_Digitos;

    VL_Dados := '0000' + HexStr((VL_Digitos), 1) + IntToStr(VL_TamanhoPacote) + VL_Dados;
    VO_Dados := VL_Dados;


    Result := 0;
end;

function TMensagem.GetTag(VP_Tag: ansistring; var VO_Dados: ansistring): integer;
var
    i: integer;
begin
    //Verifica se existe o pacote
    if length(fTags) = 0 then
    begin
        Result := 22;
        Exit;
    end;
    //Verifica se o parametro é nulo ou diferente da estrutura
    if Length(VP_Tag) <> 4 then
    begin
        Result := 28;
        Exit;
    end;
    for i := 0 to length(fTags) - 1 do
    begin
        if fTags[i].Tag = VP_Tag then
        begin
            VO_Dados := fTags[i].Dados;
            Result := 0;
            Exit;
        end;
    end;
    //Tag não encontrada no pacote
    Result := 29;
end;

function TMensagem.GetTag(VP_Posicao: integer; var VO_Tag: ansistring; var VO_Dados: ansistring): integer;
begin
    Result := 0;
    if Length(fTags) > VP_Posicao then
    begin
        VO_Tag := fTags[VP_Posicao].Tag;
        VO_Dados := fTags[VP_Posicao].Dados;
    end;
end;

function TMensagem.GetTag(VP_Posicao: integer; var VO_Tag: TTag): integer;
begin
    Result := 0;
    if Length(fTags) > VP_Posicao then
    begin
        VO_Tag := fTags[VP_Posicao];
    end;
end;

function TMensagem.GetTag(VP_Tag: ansistring; var VO_Dados: int64): int64;
var
    i: integer;
begin
    //Verifica se existe o pacote
    if length(fTags) = 0 then
    begin
        Result := 22;
        Exit;
    end;
    //Verifica se o parametro é nulo ou diferente da estrutura
    if Length(VP_Tag) <> 4 then
    begin
        Result := 28;
        Exit;
    end;
    for i := 0 to length(fTags) - 1 do
    begin
        if fTags[i].Tag = VP_Tag then
        begin
            VO_Dados := StrToInt(fTags[i].Dados);
            Result := 0;
            Exit;
        end;
    end;
    //Tag não encontrada no pacote
    Result := 29;
end;

function TMensagem.GetTagAsAstring(VP_Tag: ansistring): ansistring;
var
    VL_String: ansistring;
begin
    Result := '';
    VL_String := '';
    if GetTag(VP_Tag, VL_String) = 0 then
        Result := VL_String;
end;

function TMensagem.Comando: ansistring;
begin
    if Length(fTags) > 0 then
    begin
        Result := fTags[0].Tag;
    end;

end;

function TMensagem.ComandoDados: ansistring;
begin
    if Length(fTags) > 0 then
    begin
        Result := fTags[0].Dados;
    end;

end;

function TMensagem.TagsAsString: ansistring;
begin
    Result := '';
    TagToStr(Result);
end;

function TMensagem.TagCount: integer;
begin
    Result := Length(fTags) - 1;
end;

function TMensagem.GetTagAsInteger(VP_Tag: ansistring): integer;
var
    VL_String: ansistring;
begin
    Result := 0;
    VL_String := '';
    if GetTag(VP_Tag, VL_String) = 0 then
        if VL_String <> '' then
            Result := StrToInt(VL_String);
end;


function TMensagem.AddTag(VP_Tag, VP_Dados: ansistring): integer;
var
    i: integer;

    procedure incluir(VP_Posicao: integer);
    begin
        fTags[VP_Posicao].Tag := VP_Tag;
        fTags[VP_Posicao].Qt := HexStr(length(IntToStr(Length(VP_Dados))), 1);
        fTags[VP_Posicao].Tamanho := Length(VP_Dados);
        fTags[VP_Posicao].Dados := VP_Dados;
    end;

begin

    //Verifica se existe o pacote
    if length(fTags) = 0 then
    begin
        Result := 27;
        Exit;
    end;
    //verifica se o parametro dados contem valor
    for i := 0 to length(fTags) - 1 do
    begin
        if fTags[i].Tag = VP_Tag then
        begin
            incluir(i);
            Result := 0;
            Exit;
        end;
    end;
    SetLength(fTags, Length(fTags) + 1);
    incluir(Length(fTags) - 1);

end;

function TMensagem.AddTag(VP_Tag: ansistring; VP_Dados: integer): integer;
var
    i: integer;

    procedure incluir(VP_Posicao: integer);
    begin
        fTags[VP_Posicao].Tag := VP_Tag;
        fTags[VP_Posicao].Qt := HexStr(length(IntToStr(Length(IntToStr(VP_Dados)))), 1);
        fTags[VP_Posicao].Tamanho := Length(IntToStr(VP_Dados));
        fTags[VP_Posicao].Dados := IntToStr(VP_Dados);
    end;

begin

    //Verifica se existe o pacote
    if length(fTags) = 0 then
    begin
        Result := 27;
        Exit;
    end;
    //verifica se o parametro dados contem valor
    for i := 0 to length(fTags) - 1 do
    begin
        if fTags[i].Tag = VP_Tag then
        begin
            incluir(i);
            Result := 0;
            Exit;
        end;
    end;
    SetLength(fTags, Length(fTags) + 1);
    incluir(Length(fTags) - 1);

end;

procedure TMensagem.Limpar;
begin
    SetLength(fTags, 0);
end;

constructor TMensagem.Create;
begin
    inherited Create;
end;

function TMensagem.AddComando(VP_Tag, VP_Dados: ansistring): integer;
begin

    //Verifica se existe o pacote
    if length(fTags) = 0 then
        SetLength(fTags, Length(fTags) + 1);

    fTags[0].Tag := VP_Tag;
    fTags[0].Qt := HexStr(length(IntToStr(Length(VP_Dados))), 1);
    fTags[0].Tamanho := Length(VP_Dados);
    fTags[0].Dados := VP_Dados;

    Result := 0;
end;


initialization
    VF_Sequencia := 0;
    InitCriticalSection(VF_CriticoLog);

finalization
    DoneCriticalSection(VF_CriticoLog);
end.
